syntax = "proto3";

package envoy.service.auth.v2;

option java_outer_classname = "ExternalAuthProto";
option java_multiple_files = true;
option java_package = "io.envoyproxy.envoy.service.auth.v2";
//option go_package = "v2";
option java_generic_services = true;


import "google/protobuf/any.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/timestamp.proto";


message HeaderValue {
  // Header name.
  string key = 1;

  // Header value.
  //
  // The same :ref:`format specifier <config_access_log_format>` as used for
  // :ref:`HTTP access logging <config_access_log>` applies here, however
  // unknown header values are replaced with the empty string instead of `-`.
  string value = 2;
}

// Header name/value pair plus option to control append behavior.
message HeaderValueOption {
  // Header name/value pair that this option applies to.
  HeaderValue header = 1;

  // Should the value be appended? If true (default), the value is appended to
  // existing values.
  google.protobuf.BoolValue append = 2;
}


enum StatusCode {
  // Empty - This code not part of the HTTP status code specification, but it is needed for proto
  // `enum` type.
  Empty = 0;

  Continue = 100;

  OK = 200;
  Created = 201;
  Accepted = 202;
  NonAuthoritativeInformation = 203;
  NoContent = 204;
  ResetContent = 205;
  PartialContent = 206;
  MultiStatus = 207;
  AlreadyReported = 208;
  IMUsed = 226;

  MultipleChoices = 300;
  MovedPermanently = 301;
  Found = 302;
  SeeOther = 303;
  NotModified = 304;
  UseProxy = 305;
  TemporaryRedirect = 307;
  PermanentRedirect = 308;

  BadRequest = 400;
  Unauthorized = 401;
  PaymentRequired = 402;
  Forbidden = 403;
  NotFound = 404;
  MethodNotAllowed = 405;
  NotAcceptable = 406;
  ProxyAuthenticationRequired = 407;
  RequestTimeout = 408;
  Conflict = 409;
  Gone = 410;
  LengthRequired = 411;
  PreconditionFailed = 412;
  PayloadTooLarge = 413;
  URITooLong = 414;
  UnsupportedMediaType = 415;
  RangeNotSatisfiable = 416;
  ExpectationFailed = 417;
  MisdirectedRequest = 421;
  UnprocessableEntity = 422;
  Locked = 423;
  FailedDependency = 424;
  UpgradeRequired = 426;
  PreconditionRequired = 428;
  TooManyRequests = 429;
  RequestHeaderFieldsTooLarge = 431;

  InternalServerError = 500;
  NotImplemented = 501;
  BadGateway = 502;
  ServiceUnavailable = 503;
  GatewayTimeout = 504;
  HTTPVersionNotSupported = 505;
  VariantAlsoNegotiates = 506;
  InsufficientStorage = 507;
  LoopDetected = 508;
  NotExtended = 510;
  NetworkAuthenticationRequired = 511;
}

// HTTP status.
message HttpStatus {
  // Supplies HTTP response code.
  StatusCode code = 1;
}



message Address {
  oneof address {
    SocketAddress socket_address = 1;
    Pipe pipe = 2;
  }
}

message Pipe {
  // Unix Domain Socket path. On Linux, paths starting with '@' will use the
  // abstract namespace. The starting '@' is replaced by a null byte by Envoy.
  // Paths starting with '@' will result in an error in environments other than
  // Linux.
  string path = 1;
}

message SocketAddress {
  enum Protocol {
    TCP = 0;
    // [#not-implemented-hide:]
    UDP = 1;
  }
  Protocol protocol = 1;
  // The address for this socket. :ref:`Listeners <config_listeners>` will bind
  // to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
  // to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
  // It is possible to distinguish a Listener address via the prefix/suffix matching
  // in :ref:`FilterChainMatch <envoy_api_msg_listener.FilterChainMatch>`.] When used
  // within an upstream :ref:`BindConfig <envoy_api_msg_core.BindConfig>`, the address
  // controls the source address of outbound connections. For :ref:`clusters
  // <envoy_api_msg_Cluster>`, the cluster type determines whether the
  // address must be an IP (*STATIC* or *EDS* clusters) or a hostname resolved by DNS
  // (*STRICT_DNS* or *LOGICAL_DNS* clusters). Address resolution can be customized
  // via :ref:`resolver_name <envoy_api_field_core.SocketAddress.resolver_name>`.
  string address = 2;
  oneof port_specifier {
    uint32 port_value = 3;
    // This is only valid if :ref:`resolver_name
    // <envoy_api_field_core.SocketAddress.resolver_name>` is specified below and the
    // named resolver is capable of named port resolution.
    string named_port = 4;
  }
  // The name of the custom resolver. This must have been registered with Envoy. If
  // this is empty, a context dependent default applies. If the address is a concrete
  // IP address, no resolution will occur. If address is a hostname this
  // should be set for resolution other than DNS. Specifying a custom resolver with
  // *STRICT_DNS* or *LOGICAL_DNS* will generate an error at runtime.
  string resolver_name = 5;

  // When binding to an IPv6 address above, this enables `IPv4 compatibility
  // <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
  // allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
  // IPv6 space as ``::FFFF:<IPv4-address>``.
  bool ipv4_compat = 6;
}


message AttributeContext {
  // This message defines attributes for a node that handles a network request.
  // The node can be either a service or an application that sends, forwards,
  // or receives the request. Service peers should fill in the `service`,
  // `principal`, and `labels` as appropriate.
  message Peer {
    // The address of the peer, this is typically the IP address.
    // It can also be UDS path, or others.
    Address address = 1;

    // The canonical service name of the peer.
    // It should be set to :ref:`the HTTP x-envoy-downstream-service-cluster
    // <config_http_conn_man_headers_downstream-service-cluster>`
    // If a more trusted source of the service name is available through mTLS/secure naming, it
    // should be used.
    string service = 2;

    // The labels associated with the peer.
    // These could be pod labels for Kubernetes or tags for VMs.
    // The source of the labels could be an X.509 certificate or other configuration.
    map<string, string> labels = 3;

    // The authenticated identity of this peer.
    // For example, the identity associated with the workload such as a service account.
    // If an X.509 certificate is used to assert the identity this field should be sourced from
    // `Subject` or `Subject Alternative Names`. The primary identity should be the principal.
    // The principal format is issuer specific.
    //
    // Example:
    // *    SPIFFE format is `spiffe://trust-domain/path`
    // *    Google account format is `https://accounts.google.com/{userid}`
    string principal = 4;
  }

  // Represents a network request, such as an HTTP request.
  message Request {
    // The timestamp when the proxy receives the first byte of the request.
    google.protobuf.Timestamp time = 1;

    // Represents an HTTP request or an HTTP-like request.
    HttpRequest http = 2;

    // More request types are added here as necessary.
  }

  // This message defines attributes for an HTTP request.
  // HTTP/1.x, HTTP/2, gRPC are all considered as HTTP requests.
  message HttpRequest {
    // The unique ID for a request, which can be propagated to downstream
    // systems. The ID should have low probability of collision
    // within a single day for a specific service.
    // For HTTP requests, it should be X-Request-ID or equivalent.
    string id = 1;

    // The HTTP request method, such as `GET`, `POST`.
    string method = 2;

    // The HTTP request headers. If multiple headers share the same key, they
    // must be merged according to the HTTP spec. All header keys must be
    // lowercased, because HTTP header keys are case-insensitive.
    map<string, string> headers = 3;

    // The request target, as it appears in the first line of the HTTP request. This includes
    // the URL path and query-string. No decoding is performed.
    string path = 4;

    // The HTTP request `Host` or 'Authority` header value.
    string host = 5;

    // The HTTP URL scheme, such as `http` and `https`.
    string scheme = 6;

    // This field is always empty, and exists for compatibility reasons. The HTTP URL query is
    // included in `path` field.
    string query = 7;

    // This field is always empty, and exists for compatibility reasons. The URL fragment is
    // not submitted as part of HTTP requests; it is unknowable.
    string fragment = 8;

    // The HTTP request size in bytes. If unknown, it must be -1.
    int64 size = 9;

    // The network protocol used with the request, such as "HTTP/1.0", "HTTP/1.1", or "HTTP/2".
    //
    // See :repo:`headers.h:ProtocolStrings <source/common/http/headers.h>` for a list of all
    // possible values.
    string protocol = 10;

    // The HTTP request body.
    string body = 11;
  }

  // The source of a network activity, such as starting a TCP connection.
  // In a multi hop network activity, the source represents the sender of the
  // last hop.
  Peer source = 1;

  // The destination of a network activity, such as accepting a TCP connection.
  // In a multi hop network activity, the destination represents the receiver of
  // the last hop.
  Peer destination = 2;

  // Represents a network request, such as an HTTP request.
  Request request = 4;

  // This is analogous to http_request.headers, however these contents will not be sent to the
  // upstream server. Context_extensions provide an extension mechanism for sending additional
  // information to the auth server without modifying the proto definition. It maps to the
  // internal opaque context in the filter chain.
  map<string, string> context_extensions = 10;
}


// [#protodoc-title: Authorization Service ]

// The authorization service request messages used by external authorization :ref:`network filter
// <config_network_filters_ext_authz>` and :ref:`HTTP filter <config_http_filters_ext_authz>`.

// A generic interface for performing authorization check on incoming
// requests to a networked service.
service Authorization {
  // Performs authorization check based on the attributes associated with the
  // incoming request, and returns status `OK` or not `OK`.
  rpc Check(CheckRequest) returns (CheckResponse);
}

message CheckRequest {
  // The request attributes.
  AttributeContext attributes = 1;
}

// HTTP attributes for a denied response.
message DeniedHttpResponse {
  // This field allows the authorization service to send a HTTP response status
  // code to the downstream client other than 403 (Forbidden).
  HttpStatus status = 1;

  // This field allows the authorization service to send HTTP response headers
  // to the downstream client.
  repeated HeaderValueOption headers = 2;

  // This field allows the authorization service to send a response body data
  // to the downstream client.
  string body = 3;
}

// HTTP attributes for an ok response.
message OkHttpResponse {
  // HTTP entity headers in addition to the original request headers. This allows the authorization
  // service to append, to add or to override headers from the original request before
  // dispatching it to the upstream. By setting `append` field to `true` in the `HeaderValueOption`,
  // the filter will append the correspondent header value to the matched request header. Note that
  // by Leaving `append` as false, the filter will either add a new header, or override an existing
  // one if there is a match.
  repeated HeaderValueOption headers = 2;
}

message RPCStatus {
  // The status code, which should be an enum value of
  // [google.rpc.Code][google.rpc.Code].
  int32 code = 1;

  // A developer-facing error message, which should be in English. Any
  // user-facing error message should be localized and sent in the
  // [google.rpc.Status.details][google.rpc.Status.details] field, or localized
  // by the client.
  string message = 2;

  // A list of messages that carry the error details.  There is a common set of
  // message types for APIs to use.
  repeated google.protobuf.Any details = 3;
}

// Intended for gRPC and Network Authorization servers `only`.
message CheckResponse {
  // Status `OK` allows the request. Any other status indicates the request should be denied.
  RPCStatus status = 1;

  // An message that contains HTTP response attributes. This message is
  // used when the authorization service needs to send custom responses to the
  // downstream client or, to modify/add request headers being dispatched to the upstream.
  oneof http_response {
    // Supplies http attributes for a denied response.
    DeniedHttpResponse denied_response = 2;

    // Supplies http attributes for an ok response.
    OkHttpResponse ok_response = 3;
  }
}
